<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="style.css" />
<svg id="svg" viewBox="-500 -500 1000 1000">
    <g id="transformed" fill="green" fill-opacity="0.5" />
    <g fill="black" fill-opacity="0.5">
        <polygon id="pentagon" stroke="black" stroke-width="1mm" />
    </g>
    <g id="vertices" />
</svg>
<script src="common.js"></script>
<script>

const baseEdges = {
    f: { dx: 3, dy: 5 },
    a: { dx: 6, dy: 2 },
    c: { dx: 3, dy: -3 },
    h: { dx: -3, dy: 3 },
    r: { dx: -2, dy: -6 },
    R: { dx: -2, dy: -6 },
};
function negate(v) { return { dx: -v.dx, dy: -v.dy }; }
function swap(v) { return { dx: v.dy, dy: v.dx }; }
function apply(vs, fs) {
    const result = {};
    for (const k in vs) {
        let v = vs[k];
        for (const f of fs) v = f(v);
        result[k] = v;
    }
    return result;
}
const edgesByClass = [];
edgesByClass[0] = apply(baseEdges, []);
edgesByClass[2] = apply(baseEdges, [negate]);
edgesByClass[6] = apply(baseEdges, [negate, swap]);
edgesByClass[8] = apply(baseEdges, [swap]);

function mod(a, b) {
    let r = a % b;
    if (r < 0) r += b;
    return r;
}

function edgesFrom(p) {
    const edges = edgesByClass[mod(p.y - p.x, 12)];
    const outEdges = {}
    const log = p.x == 3 && p.y == -3;
    console.log(p, log, edges);
    for (const xfm in edges) {
        const e = edges[xfm];
        const neighbour = { x: p.x + e.dx, y: p.y + e.dy };
        if (log) console.log(xfm, neighbour, inBounds(neighbour));
        if (inBounds(neighbour))
            outEdges[xfm] = neighbour;
    }
    return outEdges;
}

function inBounds(p) {
    const u = p.y - p.x;
    const v = p.x + p.y;
    return -16 <= u && u < 14 && Math.abs(v) <= 16;
}

function best(arr, score) {
    let bestItem = arr[0];
    let bestScore = score(bestItem);
    for (let i = 1; i < arr.length; i++) {
        const newScore = score(arr[i]);
        if (newScore > bestScore) {
            bestItem = arr[i];
            bestScore = newScore;
        }
    }
    return bestItem;
}

function pathQuality(path) {
    let quality = 0;
    for (let i = 0; i < path.length-1; i++)
        if (path.charAt(i) == path.charAt(i+1))
            quality--;
    const arr = Array.from(path);
    arr.sort();
    for (let i = 0; i < arr.length-1; i++)
        if (arr[i] != arr[i+1])
            quality++;
    return quality;
}

const paths = (function () {
    const seen = [];
    function haveSeen(node) {
        for (const seenNode of seen) {
            if (seenNode.x === node.x && seenNode.y === node.y)
                return true;
        }
        return false;
    }
    const queue = [{"": { x: 0, y: 0 }}];
    const paths = [];
    while (queue.length > 0) {
        const fan = queue.shift();
        const fanPaths = Object.keys(fan);
        if (fanPaths.length == 0)
            continue;
        const candidatePath = best(fanPaths, pathQuality);
        const candidateNode = fan[candidatePath];
        if (fanPaths.length > 1) {
            delete fan[candidatePath];
            queue.push(fan);
        }
        if (haveSeen(candidateNode))
            continue;
        paths.push(candidatePath);
        seen.push(candidateNode);
        const children = edgesFrom(candidateNode);
        const newNodes = {};
        for (const xfm in children)
            newNodes[candidatePath + xfm] = children[xfm];
        queue.push(newNodes);
    }
    paths.shift();
    return paths;
})();

pentagons({
    f: rotate180(dots[0], dots[1]),
    a: ray2rayflip(dots[3], dots[4], dots[1], dots[2]),
    c: ray2rayflip(dots[0], dots[4], dots[3], dots[2]),
    h: ray2rayflip(dots[3], dots[2], dots[0], dots[4]),
    r: ray2rayflip(dots[1], dots[2], dots[3], dots[4]),
    R: ray2rayflip(dots[2], dots[1], dots[4], dots[3]),
}, paths);

</script>

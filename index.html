<!DOCTYPE html>
<html xmlns:xlink="http://www.w3.org/1999/xlink">
<head>
<meta charset='utf-8'>
<style type="text/css">
    * { box-sizing: border-box; }
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
    }
    html {
        width: 100vw;
        height: 100vh;
    }
    body, svg {
        width: 100%;
        height: 100%;
    }
    body { background-color: white; }
</style>
</head>
<body>
<svg id="svg" viewBox="-500 -500 1000 1000">
    <g id="transformed" fill="yellow" fill-opacity="0.5" />
    <g fill="blue" fill-opacity="0.5">
        <polygon id="pentagon" stroke="black" stroke-width="1mm" />
    </g>
    <g id="vertices" />
</svg>
<script type="text/javascript">
const SVGNS = "http://www.w3.org/2000/svg";

const dragging = {dx: 0, dy: 0, target: null};
const svg = document.querySelector("svg");
svg.addEventListener("mousemove", move, false);
document.body.addEventListener("mouseup", stopDragging, false);
document.body.addEventListener("mouseleave", stopDragging, false);

function event2svg(event) {
    const p = svg.createSVGPoint();
    p.x = event.clientX;
    p.y = event.clientY;
    const q = p.matrixTransform(svg.getScreenCTM().inverse());
    return {x: q.x, y: q.y};
}

function move(event) {
    target = dragging.target;
    if (target != null) {
        const p = event2svg(event);
        target.set({
            x: p.x + dragging.dx,
            y: p.y + dragging.dy
        });
    }
}

function stopDragging(event) {
    dragging.target = null;
}

function startDragging(v) {
    return function (event) {
        const p = v.value;
        const svgpt = event2svg(event);
        dragging.dx = p.x - svgpt.x;
        dragging.dy = p.y - svgpt.y;
        dragging.target = v;
    }
}

const variables = [];

class Variable {
    constructor(dependencies) {
        this.dirty = false;
        this.dependents = [];
        variables.push(this);
        for (const dep of dependencies)
            dep.dependents.push(this);
    }

    update() {
        if (this.dirty) {
            const newValue = this.compute();
            if (newValue != this.value) {
                this.value = newValue;
                for (const dep of this.dependents)
                    dep.dirty = true;
            }
            this.dirty = false;
        }
    }
}

update = (function () {
    let update_scheduled = false;
    return function () {
        if (!update_scheduled) {
            setTimeout(function () {
                update_scheduled = false;
                for (const v of variables)
                    v.update();
            });
            update_scheduled = true;
        }
    };
})();

class Store extends Variable {
    constructor(initialValue) {
        super([]);
        this.set(initialValue);
    }
    compute() {
        return this.newValue;
    }
    set(value) {
        this.newValue = value;
        this.dirty = true;
        update();
    }
}

function variable(dependencies, compute) {
    const v = new Variable(dependencies);
    v.compute = function () {
        return compute.apply(null,
            dependencies.map(function (x) { return x.value; }));
    };
    return v;
}

function visibility(boolvar, elem) {
    return variable([boolvar], function (vis) {
        elem.setAttribute("visibility", vis ? "visible" : "hidden");
    });
}

function xy(pvar, elem) {
    return variable([pvar], function (p) {
        elem.setAttribute("x", p.x);
        elem.setAttribute("y", p.y);
    });
}

function centre(pvar, circle) {
    return variable([pvar], function (p) {
        circle.setAttribute("cx", p.x);
        circle.setAttribute("cy", p.y);
    });
}

function polygon(vertexvars, gon) {
    return variable(vertexvars, function () {
        const strings = [];
        for (const p of arguments)
            strings.push(p.x + "," + p.y);
        gon.setAttribute("points", strings.join(" "));
    });
}

function gtransform(tvar, g) {
    return variable([tvar], function (t) {
        g.setAttribute("transform", t);
    });
}

function rotate180(pvar, qvar) {
    return variable([pvar, qvar], function (p, q) {
        const m = {x: (p.x + q.x)/2, y: (p.y + q.y)/2};
        return "rotate(180 " + m.x + " " + m.y + ")";
    });
}

function ray2ray(p1var, q1var, p2var, q2var) {
    return variable([p1var, q1var, p2var, q2var], function (p1, q1, p2, q2) {
        const tr = {x: p2.x - p1.x, y: p2.y - p1.y};
        const translate = "translate(" + tr.x + " " + tr.y + ")";
        const ang1 = Math.atan2(q1.y - p1.y, q1.x - p1.x);
        const ang2 = Math.atan2(q2.y - p2.y, q2.x - p2.x);
        const rot = (ang2 - ang1)*180/Math.PI
        const rotate = "rotate(" + rot + " " + p2.x + " " + p2.y + ")";
        return rotate + translate;
    });
}

function centroid(pointvars) {
    return variable(pointvars, function () {
        let n = 0, x = 0, y = 0;
        for (const p of arguments) {
            n++;
            x += p.x;
            y += p.y;
        }
        return {x: x/n, y: y/n};
    });
}

const vertices = document.querySelector("#vertices");
const dots = [];
for (let i = 0; i < 5; i++) {
    const circle = document.createElementNS(SVGNS, "circle");
    circle.setAttribute("r", "3mm");
    vertices.appendChild(circle);
    const angle = (i/5 - 1/4)*2*Math.PI;
    const dot = new Store({x: 60*Math.cos(angle), y: 60*Math.sin(angle)});
    dots.push(dot);
    centre(dot, circle);
    circle.addEventListener("mousedown", startDragging(dot), false);
}
polygon(dots, document.querySelector("#pentagon"));

const xfm = {
    a: rotate180(dots[4], dots[0]),
    b: rotate180(dots[0], dots[1]),
    h: rotate180(dots[2], dots[3]),
    u: ray2ray(dots[4], dots[3], dots[1], dots[2]),
    v: ray2ray(dots[1], dots[2], dots[4], dots[3]),
};

const specs = [
    "a",
    "ah",
    "ahv",
    "ahu",
    "b",
    "h",
    "ha",
    "hb",
    "hu",
    "hub",
    "v",
    "va",
    "vv",
    "vvh",
    "u",
    "ub",
    "ubh",
    "uu",
    "uuh",
    "uuhb",
    "uuhba",
];

const labelsVisible = new Store(false);
const labelLocation = centroid(dots);
const transformed = document.querySelector("#transformed");
for (const spec of specs) {
    let base = transformed;
    for (const c of spec) {
        const g = document.createElementNS(SVGNS, "g");
        gtransform(xfm[c], g);
        base.appendChild(g);
        base = g;
    }
    const use = document.createElementNS(SVGNS, "use");
    use.setAttribute("href", "#pentagon");
    base.appendChild(use);
    const text = document.createElementNS(SVGNS, "text");
    text.appendChild(document.createTextNode(spec));
    text.setAttribute("fill", "black");
    text.setAttribute("fill-opacity", "1");
    text.setAttribute("text-anchor", "middle");
    base.appendChild(text);
    xy(labelLocation, text);
    visibility(labelsVisible, text);
}
</script>
</body>
</html>
